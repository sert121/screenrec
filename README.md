# **ace screenrecord**

This project is a screen recording application built using the Tauri framework, with a frontend developed in React(TS)


## **Project Structure and File Descriptions**

This section details the purpose of each file and directory within the project.



### **src/**

This directory contains the source code for the React frontend application.

- **src/App.css**: Contains global CSS styles for the main application container and basic element styling (input, button, h1).

- **src/App.tsx**: The main React component that renders the application's UI. It currently includes the RecordingControls component.

- **src/main.tsx**: The entry point for the React application. It uses ReactDOM.createRoot to render the App component into the #root element in index.html.

- **src/vite-env.d.ts**: A declaration file for Vite's client environment variables.

- **src/components/**: Contains reusable React components.

* **src/components/RecordingControls.tsx**: A React component that provides the user interface for controlling the screen recording (start/stop button, duration display). It interacts with the Tauri backend via invoke and uses the RecordingFactory service.

- **src/platforms/**: Contains platform-specific implementations for screen recording.

* **src/platforms/mac/mac-recording.service.ts**: Implements the RecordingService interface for macOS. It uses the native screencapture command via Tauri's Command API.

* **src/platforms/windows/windows-recording.service.ts**: Implements the RecordingService interface for Windows. 
- **src/services/**: Contains service classes for application logic.

* **src/services/recording-factory.service.ts**: A factory class responsible for creating the appropriate RecordingService instance based on the detected platform. It interacts with the Tauri backend to get the platform information.

* **src/services/recording.service.ts**: An abstract base class for recording services (BaseRecordingService). It defines the common interface (RecordingService) and provides shared logic like the duration timer.

- **src/styles/**: Contains CSS files for specific components.

* **src/styles/RecordingControls.css**: Contains specific styles for the RecordingControls component.

- **src/types/**: Contains Typescript type definitions and interfaces.

* **src/types/recording.ts**: Defines interfaces for RecordingOptions, RecordingState, RecordingService, Platform, and RecordingStats.


### **src-tauri/**

This directory contains the Rust source code for the Tauri backend.

- **src-tauri/build.rs**: A Rust build script. In this case, it simply calls tauri\_build::build(), which is necessary for Tauri to generate the necessary build artifacts.

- **src-tauri/Cargo.lock**: Automatically generated by Cargo (Rust's package manager). It records the exact versions of all dependencies used in the build to ensure reproducible builds.

- **src-tauri/Cargo.toml**: The manifest file for the Rust project. It declares dependencies (including Tauri), defines the package, and configures the build. (This file was not provided in the input but is essential for a Tauri project).

- **src-tauri/src/**: Contains the main Rust source code for the backend logic.

* **src-tauri/src/main.rs**: The entry point for the Rust backend. It initializes the Tauri application, defines the backend commands (greet, get\_platform, start\_recording, stop\_recording, get\_recording\_state), and handles communication with the frontend. (This file was not provided in the input but is essential).


## **Overview**

The application's core functionality revolves around the RecordingControls component interacting with the Tauri backend `(lib.rs)` via defined commands.

1. **Initialization**: On startup, the RecordingControls component invokes the get\_platform command to determine the operating system. It then uses the RecordingFactory to instantiate the appropriate platform-specific recording service (though the provided frontend code seems to directly invoke backend commands rather than using the client-side service implementations).

2. **Starting Recording**: When the "Start Recording" button is clicked, the handleStartRecording function is called. This function invokes the start\_recording Tauri command, passing the desired recording options.

3. **Stopping Recording**: When the "Stop Recording" button is clicked, the handleStopRecording function is called. This function invokes the stop\_recording Tauri command. The backend is expected to return the path where the recording was saved.

4. **Duration Display**: A timer is managed in the RecordingControls component to display the elapsed recording time.

5. **State Management**: The RecordingControls component maintains state for whether a recording is in progress, the duration, and any errors. It also attempts to get the initial recording state from the backend when the component mounts and when the application window becomes visible.

6. **Platform-Specific Implementation**: The actual recording logic is intended to be handled in the Rust backend, using platform-specific APIs or commands (screencapture on macOS, potentially others on Windows) invoked by the frontend commands. The client-side service files (mac-recording.service.ts, windows-recording.service.ts) seem to be a potential alternative or supplementary approach, but the current RecordingFactory and RecordingControls primarily rely on direct Tauri invoke calls to backend commands.

7. **Recording** We handle the frame processing logic in rust in lib.rs. Here we launch a separate process that can ingest the frames to an input pipe provided by ffmpeg, this allows us to not store all the images on disk at the same time. When the recording is stoppped ffmpeg compresses the video for us and saves it in a recording folder (in the home directory). 

8. **Keylogging/Event Capturing** To capture the event we run a separate process via cargo, that uses `rdev` to keep track of all the user activities that are being performed on the screen when the user moves around or performs any actions (keypresses, clicks, scrolls etc). The script to track  these events is launched in `lib.rs` and core logic being present in `examples/screen_capture.rs`


## **Development and Building**

To run and build the application, you would typically use the Tauri CLI commands defined in package.json:

- npm install:  Installs required application packages
- npm run tauri dev: Starts the application in development mode with hot-reloading.


If using yarn:
 - yarn install: Installs required application packages
 - yarn tauri dev: Starts the application in development mode with hot-reloading.
